use super::components::{CurrentBoard, TileType};
use crate::{vectors::Vector2Int, DelayedStart};
use bevy::{prelude::*, utils::hashbrown::HashMap};

pub fn create_map(
    mut commands: Commands,
    time: Res<Time>,
    mut q: Query<(&mut DelayedStart, Entity)>,
) {
    let Ok((mut timer, entity)) = q.get_single_mut() else {
        return;
    };
    timer.0.tick(time.delta());
    if !timer.0.finished() {
        return;
    }
    commands.entity(entity).despawn();
    info!("Start world generate");

    // in reality, you'd probably want to import a map generated by an
    // external tool, or maybe proc-gen it yourself. For this example, a
    // 2d array should suffice.
    #[rustfmt::skip] // irony - we do it to make it more readable 
    let mut map = vec![
        vec![TileType::None, TileType::None, TileType::None, TileType::None, TileType::None, TileType::BaseFloor,  TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor ],
        vec![TileType::None, TileType::None, TileType::None, TileType::None, TileType::None, TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor  ],
        vec![TileType::None, TileType::None, TileType::None, TileType::None, TileType::None, TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor  ],
        vec![TileType::None, TileType::None, TileType::None, TileType::None, TileType::None, TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor  ],
        vec![TileType::None, TileType::None, TileType::None, TileType::None, TileType::None, TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor  ],
        vec![TileType::None, TileType::None, TileType::None, TileType::None, TileType::None, TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor  ],
        vec![TileType::None, TileType::None, TileType::None, TileType::None, TileType::None, TileType::BaseFloor,  TileType::BaseFloor, TileType::BaseFloor,  TileType::BaseFloor, TileType::BaseFloor,  TileType::BaseFloor,   TileType::BaseFloor ],
        vec![TileType::None, TileType::None, TileType::None, TileType::None, TileType::None, TileType::None, TileType::None, TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::None, TileType::None],
        vec![TileType::None, TileType::None, TileType::None, TileType::None, TileType::None, TileType::None, TileType::None, TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::None, TileType::None],
        vec![TileType::None, TileType::None, TileType::None, TileType::None, TileType::None, TileType::None, TileType::BaseFloor, TileType::BaseFloor, TileType::BaseFloor,  TileType::BaseFloor, TileType::BaseFloor,  TileType::None],
        vec![TileType::None, TileType::None, TileType::None, TileType::None, TileType::None, TileType::None, TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::None],
        vec![TileType::None, TileType::None, TileType::None, TileType::None, TileType::None, TileType::None, TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::None],
        vec![TileType::None, TileType::None, TileType::None, TileType::None, TileType::None, TileType::None, TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::None],
        vec![TileType::None, TileType::None, TileType::None, TileType::None, TileType::None, TileType::None, TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::None],
        vec![TileType::BaseFloor,  TileType::BaseFloor,    TileType::BaseFloor, TileType::None, TileType::None, TileType::None, TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::None],
        vec![TileType::BaseFloor,   TileType::BaseFloor,  TileType::BaseFloor,  TileType::BaseFloor,  TileType::BaseFloor,  TileType::BaseFloor, TileType::BaseFloor,TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::None],
        vec![TileType::BaseFloor,  TileType::BaseFloor,    TileType::BaseFloor, TileType::None, TileType::None, TileType::None, TileType::BaseFloor,  TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,   TileType::BaseFloor,  TileType::None],
    ];

    // add padding to the map
    map.insert(0, vec![TileType::None; map[0].len()]);
    map.push(vec![TileType::None; map[0].len()]);
    for row in map.iter_mut() {
        row.insert(0, TileType::None);
        row.push(TileType::None);
    }
    let mut tiles = HashMap::new();

    for (y, y_map) in map.iter().enumerate() {
        for (x, tile_type) in y_map.iter().enumerate() {
            if tile_type != &TileType::None {
                tiles.insert(
                    Vector2Int {
                        x: x as i32,
                        y: y as i32,
                    },
                    tile_type.clone(),
                );
            }
        }
    }

    commands.insert_resource(CurrentBoard { tiles });
}
